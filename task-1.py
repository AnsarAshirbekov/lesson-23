# а) Напишите функцию, которая будет создавать файл и записывать в него
# рандомное число, с задержкой 1 секунду.
# б) Запустите циклом 1000 таких функций, а также замерьте время.
# в) Добавьте функционал мультипоточного запуска, с замером времени.
# Обязательно посмотрите нагрузку на ЦП в этот момент (через диспетчер задач).

# Процесс - это выполнение программы, позволяющее выполнять действия, указанные в программе (коде).
# Процесс состоит из потоков, содержит свою собственную память и ресурсы. 
# Процессы обеспечивают более высокий уровень изоляции и независимости друг от друга, что позволяет легко 
# реализовывать параллельные вычисления, но требует сложных механизмов обмена данными.
# В отличие от потоков в многопоточности, процессы в мультипроцессорности не могут обмениваться между собой
# данными без использования механизмов межпроцессорного взаимодействия (IPC).
# Многопоточность лучше использовать для таких задач, где нет необходимости обмена данными, такие как операции 
# с вводом-выводом (сетевые операции, работа с файлами и т.д.), а мультипроцессорность для решения сложных 
# вычислительных операций, где нужен обмен данными.

# Решение задачи структурно такое же, как если бы использовали многопоточность.

import time
import random
from multiprocessing import Process

def write_random_numbers(i):
    time.sleep(1)
    random_number = random.randint(1, 100)
    with open(f"random_numbers_{i}.txt", "w") as file:
        file.write(f"{random_number}")

# Основное различие от задачи с предыдущего занятия с многопоточностью состоит в том, что мы всю программу, необходимую
# для работы с процессами, помещаем в блок if __name__ == "__main__", в который записывается выполнение определенного кода 
# только в том случае, если скрипт запущен напрямую как основной модуль, а не импортирован как модуль в другой программе.
# В этом случае здесь создастся основной процесс-родитель, который выполнит этот скрипт полностью и создаст внутри себя 
# 1000 дочерних процессов, которые в свою очередь будут вызывать функцию. Это необходимо для того, чтобы время start и end
# у нас распечатались в один раз в рамках одного основного процесса-родителя. Если же вынести start и end за пределы блока
# if __name__ == "__main__", как это было в задаче с многопоточностью, то каждый из 1000 процессов будет к ним обращаться,
# и у нас распечатается start и end 1000 раз!

if __name__ == "__main__":

    start = time.time()
    print(start)

    processes = []    

    for i in range(1000):
        # Класс Process работает практически также, как и класс Thread и имеет схожий интерфейс
        process = Process(target=write_random_numbers, args=(i, ))
        process.start()
        processes.append(process)

    for process in processes:
        process.join()

    end = time.time()
    print(f'Execution time = {end - start} seconds')